function [const, opt] = runOptimization(const, opt)
%function to perform all optimization steps
%   Generates arrays for opt, precalculate values
%   Iterates through all points
%   Finds maximum

%% pre-calculate anything that only needs to run once

% %convert to price per kg for CO2 from price per ton
% const.priceCarbon = const.priceCarbon * (1/1016.04691);

%convert interest rate to decimal
const.r = const.r/100;

%total energy demand for year 1:
const.energyLoad = sum(const.load,'omitnan')*1; %hour increments

%overloads at original (nameplate capacity with no solar+BESS)
[const] = calcOverloadsOrig_opt(const);
%INPUTS: const.load, const.npCapacity, const.time
%OUTPUTS: const.npOverloadsOrig,const.durationOverloadOrig,const.intensityOverloadOrig,const.timeOverloadOrig,const.isDamagingOrig

% OLD method
% %revenue from solar MWh of generation and BESS load shifting
% const.gainsPerMWhSolar = (const.peakGenCostPerMWh + const.offPeakGenCostPerMWh)/2; %average peak/off peak generation cost
% const.gainsPerMWhBESS = const.peakGenCostPerMWh - const.offPeakGenCostPerMWh;      %assume BESS discharges during peak time, use difference between on and off peak cost of generation

%determine cost of energy generaiton for every hour, in USD/MWh
const.timeOfDay = zeros(length(const.load),1);
const.hourCostOfGen = zeros(length(const.load),1);

for i = 1:length(const.load) %through all hours
    %determine hour in day
    if i == 1
        const.timeOfDay(i) = const.initalTimeOfDay;
    else
        const.timeOfDay(i) = const.timeOfDay(i-1) + 1; %increment by 1hr
    end
    if const.timeOfDay(i) > 23 %if time is past midnight
        const.timeOfDay(i) = 0; %set to zero again for next day
    end
    %determine if on peak time/cost of generation
    if const.timeOfDay(i) >= const.peakTimeStart && const.timeOfDay(i) <= const.peakTimeEnd
        const.hourCostOfGen(i) = const.peakGenCostPerMWh; %on peak price of gen. per MWh
    else
        const.hourCostOfGen(i) = const.offPeakGenCostPerMWh; %off peak price of generation per MWh
    end
end

%% main iteration loops
% -calculate 30 year NPV for each run, store in opt. , use for loop
%run simulation for solar+BESS, store variables in runSolarBESS.
for solar_i = 1:const.solar_maxi
    runSolarBESS.solar_i = solar_i;
    %calculate solar variables, energy, etc.
    runSolarBESS.sizeSolar = opt.solarCapacity(1,solar_i); %determine size of solar array for the upcoming runs
    
    %determine the net load with solar and energy generated by solar
    [runSolarBESS] = calcLoadWithSolar_opt(const, runSolarBESS);
    %inputs: const.load, const.solarGen1MW, runSolarBESS.sizeSolar
    %outputs: runSolarBESS.netLoadSolar,runSolarBESS.solarGen,runSolarBESS.energySolar,runSolarBESS.percSolarPen
    
    for BESS_i = 1:const.BESS_maxi
        runSolarBESS.BESS_i = BESS_i;
        %iterate through runs with the same solar capacity but varying BESS
        runSolarBESS.sizeBESS = opt.BESSCapacity(BESS_i,1); %determine size of BESS for this run
        
        %determine energy and power output, net load with BESS
        %for future - add condition for different BESS algorithms
        if const.isLoadBasedBESS == 1 %determine type of charge-discharge algorithm
            [runSolarBESS] = BESSFunc3N_opt(const, runSolarBESS);
        else
            [runSolarBESS] = RealBESStFunc_opt(const, runSolarBESS);
        end
        %INPUTS: const.time,const.deltaTime,runSolarBESS.netLoadSolar,const.initialEnergyBESS,runSolarBESS.sizeBESS,const.hourPowerCapBESS,const.chargePerc,const.dischargePerc,const.dischargeFactor, const.npCapacity
        %OUTPUTS: runSolarBESS.powerOutBESS,runSolarBESS.energyBESS,runSolarBESS.energyTotBESS,runSolarBESS.netLoadBESS
        
        %determine overloads for the given run
        [runSolarBESS] = calcOverloadsBESS_opt(const, runSolarBESS);
        %INPUTS: runSolarBESS.netLoadBESS, const.npCapacity, const.time
        %OUTPUTS: runSolarBESS.npOverloadsBESS,runSolarBESS.durationOverloadBESS,runSolarBESS.intensityOverloadBESS,runSolarBESS.timeOverloadBESS,runSolarBESS.isDamagingBESS
    
        %calculate NPV for the given run at the lifetime of the system
        [runSolarBESS] = calcCosts2BESS_opt(const, runSolarBESS);
        %INPUTS: const.energyLoad,runSolarBESS.energySolar,runSolarBESS.energyTotBESS,const.percLoadGrowth,const.percSolarDeg,runSolarBESS.sizeSolar,runSolarBESS.sizeBESS,const.npCapacity,runSolarBESS.durationOverloadBESS,runSolarBESS.isDamagingBESS,const.durationOverloadOrig,const.isDamagingOrig,const.priceCarbon,const.isBlackoutAtNP
        %OUTPUTS: runSolarBESS.netCO2BESS,runSolarBESS.annualCO2BESS,runSolarBESS.NPV_BESS,runSolarBESS.annualCB_BESS
        
        %assign NPV to current position in NPV results matrix
        opt.NPVSolarAndBESS(BESS_i,solar_i) = runSolarBESS.NPV_BESS(end);
        
    end
end

%run simulation for substation upgrade
for upgrade_i = 1:const.upgrade_maxi
    runUpgrade.upgrade_i = upgrade_i;
    %run simulation for substation upgrade, store vars in runUpgrade.
    %omit BESS+Solar calculations for these
    runUpgrade.sizeUpgrade = opt.substUpgrade(upgrade_i);
    
    %determine overloads for this run
    [runUpgrade] = calcOverloadsUpgrade_opt(const, runUpgrade);
    %INPUTS: const.load, const.npCapacity, runUpgrade.sizeUpgrade, const.time
    %OUTPUTS: runUpgrade.npOverloadsUpgrade,runUpgrade.durationOverloadUpgrade,runUpgrade.intensityOverloadUpgrade,runUpgrade.timeOverloadUpgrade,runUpgrade.isDamagingUpgrade
    
    %calculate NPV after system lifetime for the subst. upgrade
    [runUpgrade] = calcCosts2Upgrade_opt(const, runUpgrade);
    %INPUTS: const.energyLoad,runSolarBESS.energySolar,const.percLoadGrowth,const.percSolarDeg,runSolarBESS.sizeSolar,runSolarBESS.sizeBESS,const.npCapacity,runUpgrade.durationOverloadUpgrade,runUpgrade.isDamagingUpgrade,const.durationOverloadOrig,const.isDamagingOrig,const.priceCarbon,const.isBlackoutAtNP
    %OUTPUTS: runUpgrade.netCO2Upgrade,runUpgrade.annualCO2Upgrade,runUpgrade.NPV_Upgrade,runUpgrade.annualCB_Upgrade
    
    %assign current NPV
    opt.NPVSubstUpgrade(upgrade_i) = runUpgrade.NPV_Upgrade(end);
end

    %note: may be able to improve program in a few ways
    %omit BESS+Solar function from substation upgrade calculations
    %calculate all status-quo costs prior to for loop (e.g. in calcCosts,
    %overloads, total energy, etc.)
    %remove calculation of any unused variables, such as adjustedOverloads

%% finish optimization:
% -identify maximum NPV
% -idenfity the best case substation upgrade, solar & BESS capacity
[opt] = calcMaxNPV(opt);
end

